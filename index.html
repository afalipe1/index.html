<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMG 2.0 - Multi-M√©todo & Multi-Liga</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #28a745;
            --danger-color: #dc3545;
        }

        body { font-family: 'Arial', sans-serif; background-color: #f8f9fa; color: #343a40; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.1); }
        h1, h2, h3 { color: var(--primary-color); border-bottom: 2px solid var(--primary-color); padding-bottom: 8px; margin-top: 25px; }
        .flex-group { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 15px; }
        .input-box { flex: 1 1 300px; background: #e9ecef; padding: 15px; border-radius: 8px; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; border: 1px solid #ced4da; border-radius: 4px; }
        button { padding: 10px 15px; background-color: var(--secondary-color); color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; margin-right: 5px; }
        button:hover { background-color: #218838; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #c82333; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
        th, td { border: 1px solid #dee2e6; padding: 10px 5px; text-align: center; }
        th { background-color: var(--primary-color); color: white; }
        .elegivel { background-color: #d4edda; }
        .aposta-ouro { background-color: #ffc107; font-weight: bold; }
        
        #log { margin-top: 20px; padding: 10px; border: 1px solid #0056b3; background-color: #e0f7ff; color: #004085; }
        #log.error { border-color: var(--danger-color); background-color: #f8d7da; color: #721c24; }

        /* --- ESTILOS DE CARD E HIST√ìRICO --- */
        .team-card { 
            flex: 1 1 250px; /* Layout ajustado para celular */
            min-width: 250px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        .team-card h3 { 
            border-bottom: 1px solid #ced4da; 
            color: #343a40;
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            font-size: 1.1em;
        }

        /* Estilo para cada item de rodada */
        .rodada-item {
            background-color: #f0f0f0;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.8em;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #ccc;
        }
        .rodada-item:hover {
            background-color: #e0e0e0;
        }
        .rodada-label { display: block; font-weight: bold; }
        .placar-ht { font-size: 0.7em; color: #666; }

        /* Cores do Hist√≥rico (Para diferenciar Vit√≥ria, Empate, Derrota) */
        .rodada-item.win { background-color: #d4edda; border-color: #c3e6cb; }
        .rodada-item.loss { background-color: #f8d7da; border-color: #f5c6cb; }
        .rodada-item.draw { background-color: #fff3cd; border-color: #ffeeba; }

        /* Marca as rodadas usadas na an√°lise (R-1, R-2, R-3) */
        .analyzed-r {
            border: 2px solid var(--primary-color); 
            font-weight: bold;
            box-shadow: 0 0 3px rgba(0, 123, 255, 0.4);
        }
        
        /* Estilo para as Rodadas Ocultas */
        .hidden-history {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; 
            padding: 5px 0;
            margin-bottom: 5px;
            border-bottom: 1px dashed #ddd; 
        }

        /* Estilo para o bot√£o de expandir/ocultar */
        .expand-button {
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-bottom: 5px;
            width: 100%; 
            transition: background-color 0.2s;
        }

        .expand-button:hover {
            background-color: #e0e0e0;
        }

        /* --- CSS para o Bot√£o Flutuante (FAB) --- */
        .fab-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            transition: background-color 0.3s, transform 0.2s;
        }
        .fab-button:hover {
            background-color: #218838;
            transform: scale(1.05);
        }

    </style>
</head>
<body>

<div class="container">
    <h1>TMG 2.0 - An√°lise Multi-Liga & Multi-M√©todo</h1>

    <div id="log">Aguardando inicializa√ß√£o do Banco de Dados Local (IndexedDB)...</div>

    <section>
        <h3>1. ‚öΩ Liga Ativa e M√©todo</h3>
        <div class="flex-group">
            <div class="input-box">
                <label>Liga Ativa:</label>
                <select id="liga-select" onchange="switchLiga()"></select>
                <div style="margin-top: 10px;">
                    <input type="text" id="nova-liga-nome" placeholder="Nome da Nova Liga">
                    <button onclick="addLiga()">Adicionar Liga</button>
                </div>
            </div>
            
            <div class="input-box">
                <label style="margin-top: 15px; display: block;">M√©todo de An√°lise:</label>
                <select id="metodo-select" onchange="setMethod()">
                    <option value="M1">M1: TMG-Chave Otimizado (GTR 3, O2.5 ou BTTS)</option>
                    <option value="M2">M2: TMG-Chave O2.5 (GTR 2, TMG ‚â• 12)</option>
                    <option value="M3">M3: TMG-Chave HT (HTGTR 3, Over 0.5 HT)</option>
                </select>
                <button class="btn-danger" onclick="deleteLiga()" style="margin-top: 10px;">Deletar Liga Ativa</button>
            </div>
        </div>
        <p style="margin-top: 10px; font-weight: bold;">Times na Liga: <span id="time-list-display"></span></p>
    </section>

    <section>
        <h3>2. üìä An√°lise e Exporta√ß√£o</h3>
        <div class="flex-group">
            <div style="flex: 1 1 200px;">
                <label>Rodada de An√°lise (R):</label>
                <input type="number" id="rodada-alvo" placeholder="Rodada Alvo (Ex: 13)" value="13" onchange="loadLigas()">
            </div>
            <button onclick="calculateAnalysis()" style="flex: 1 1 200px; align-self: flex-end;">CALCULAR CHAVE (R<span id="target-r-display">13</span>)</button>
        </div>
        <div class="flex-group" style="border-top: 1px solid #ccc; padding-top: 15px;">
            <input type="file" id="import-file" accept=".json,.html" style="flex: 1 1 200px; height: 40px;" onchange="importData(event)">
            <button onclick="exportData()" style="flex: 1 1 150px;">Exportar Dados</button>
        </div>
    </section>

    <section>
        <h3>3. üìä Hist√≥rico de Gols (Clique para Editar o Resultado)</h3>
        <p>As rodadas destacadas s√£o as √∫ltimas <span id="gtr-base-display">3</span> rodadas usadas no GTR atual. Clique no card para editar.</p>
        <div id="historico-inputs" class="flex-group">
            </div>
    </section>

    <section>
        <h3>4. üìà Resultados do GTR e Aposta Ouro</h3>
        <p>C√°lculo: <span id="gtr-calc-info"></span></p>
        <table id="gtr-table"></table>
    </section>

    <section>
        <h3>5. üéØ An√°lise de Confrontos TMG (R<span id="analysis-r-display">13</span>)</h3>
        <div class="input-box">
            <label>Adicionar Confronto (R<span id="confronto-r-display">13</span>):</label>
            <select id="time1-select" style="width: 45%; display: inline-block;"></select>
            <select id="time2-select" style="width: 45%; display: inline-block;"></select>
            <button onclick="addConfronto()">Adicionar</button>
        </div>
        <table id="tmg-table"></table>
    </section>

    <section>
        <h3>6. üîë Recomenda√ß√£o da Chave Condicionada</h3>
        <div id="chave-recomendacao"></div>
    </section>

    <section id="adicionar-rodada-section" style="display: none;">
        <h3>7. üìù Inserir Resultados de Rodada / Gerenciar Times</h3>

        <div class="flex-group">
            <div class="input-box">
                 <label>Adicionar Time √† Liga:</label>
                 <input type="text" id="novo-time-nome" placeholder="Nome do Time (Ex: Bayern)">
                 <button onclick="addTime()">Adicionar Time</button>
            </div>
             <div class="input-box">
                <label>Rodada para Inser√ß√£o/Edi√ß√£o:</label>
                <input type="number" id="rodada-input" placeholder="Rodada (Ex: 12)" min="1">
            </div>
        </div>

        <h4>Inserir/Editar Resultado (Preencha os campos e clique em Salvar)</h4>
        <div class="flex-group">
            <select id="time1-result-select" style="flex: 1;"></select>
            <input type="number" id="gm-input" placeholder="GM" style="width: 50px;" min="0">
            <span>-</span>
            <input type="number" id="gs-input" placeholder="GS" style="width: 50px;" min="0">
            <select id="time2-result-select" style="flex: 1;"></select>
        </div>

        <div class="flex-group" style="margin-top: 10px;">
            <label>1¬∫ Tempo:</label>
            <input type="number" id="gmht-input" placeholder="GM HT" style="width: 50px;" min="0">
            <span>-</span>
            <input type="number" id="gsht-input" placeholder="GS HT" style="width: 50px;" min="0">
            <button onclick="saveResultFromInputs()" style="flex: 1 1 150px;">Salvar Resultado</button>
        </div>
        
    </section>
    
</div>
<button id="add-result-fab" class="fab-button" onclick="showInputSection()">‚ûï Inserir Resultados</button>

<script>
    // --- VARI√ÅVEIS GLOBAIS ---
    let db;
    const DB_NAME = 'TmgChaveDB_v2'; 
    const DB_VERSION = 2; 
    const STORE_LIGAS = 'Ligas';
    const STORE_TIMES = 'Times';
    const STORE_CONFRONTOS = 'Confrontos';

    let currentLiga = '';
    let currentMethod = 'M1'; 
    let apostaOuroTimes = []; 

    const METHODS = {
        'M1': { name: 'TMG-Chave Otimizado', gtr_base: 3, tmg_min: 12, market: 'O2.5 OU BTTS', chave_rule: 'CHAVE_2_4', type: 'TOTAL' },
        'M2': { name: 'TMG-Chave O2.5', gtr_base: 2, tmg_min: 12, market: 'O2.5 SIMPLES', chave_rule: 'CHAVE_MULTIPLA', type: 'TOTAL' },
        'M3': { name: 'TMG-Chave HT Otimizado', gtr_base: 3, tmg_min: 6, market: 'OVER 0.5 HT', chave_rule: 'CHAVE_2_N', type: 'HT' }
    };

    // --- INDEXEDDB SETUP ---

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_LIGAS)) {
                    db.createObjectStore(STORE_LIGAS, { keyPath: 'nome' });
                }
                if (!db.objectStoreNames.contains(STORE_TIMES)) {
                    const timeStore = db.createObjectStore(STORE_TIMES, { keyPath: 'id', autoIncrement: true });
                    timeStore.createIndex('liga', 'liga', { unique: false });
                }
                if (!db.objectStoreNames.contains(STORE_CONFRONTOS)) {
                    const confrontoStore = db.createObjectStore(STORE_CONFRONTOS, { keyPath: 'id', autoIncrement: true });
                    confrontoStore.createIndex('liga_rodada', ['liga', 'rodada'], { unique: false });
                }
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                document.getElementById('log').textContent = 'Banco de Dados IndexedDB TMG 2.0 inicializado.';
                resolve(db);
                loadLigas();
            };

            request.onerror = (event) => {
                document.getElementById('log').textContent = `Erro ao abrir DB: ${event.target.errorCode}`;
                document.getElementById('log').classList.add('error');
                reject(event.target.error);
            };
        });
    }

    function transaction(storeName, mode) {
        const tx = db.transaction(storeName, mode);
        return tx.objectStore(storeName);
    }
    
    // NOVO UTILITY: Fun√ß√£o para expandir/recolher o hist√≥rico
    function toggleHistory(timeId) {
        const hiddenDiv = document.getElementById(`hidden-r-${timeId}`);
        const expandBtn = document.getElementById(`expand-btn-${timeId}`);

        if (!hiddenDiv || !expandBtn) return; 

        if (hiddenDiv.style.display === 'none') {
            hiddenDiv.style.display = 'flex'; // Mostra
            expandBtn.textContent = 'Ocultar Hist√≥rico Anterior';
        } else {
            hiddenDiv.style.display = 'none'; // Esconde
            const rodadasOcultasCount = hiddenDiv.children.length;
            expandBtn.textContent = `Mostrar ${rodadasOcultasCount} Rodadas Anteriores`;
        }
    }

    // NOVO UTILITY: Fun√ß√£o para rolar e focar na se√ß√£o de inser√ß√£o de dados (Chamada pelo FAB)
    function showInputSection() {
        const inputSection = document.getElementById('adicionar-rodada-section');
        inputSection.style.display = 'block'; // Garante que a se√ß√£o de input esteja vis√≠vel
        inputSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    // --- LIGA MANAGEMENT ---

    async function loadLigas() {
        const select = document.getElementById('liga-select');
        select.innerHTML = '';
        const store = transaction(STORE_LIGAS, 'readonly');
        const ligas = await getAllData(store);
        
        if (ligas.length === 0) {
            document.getElementById('log').textContent = 'Nenhuma liga encontrada. Adicione uma nova liga.';
            currentLiga = '';
            renderTimeList([]);
            return;
        }

        ligas.forEach(liga => {
            select.innerHTML += `<option value="${liga.nome}">${liga.nome}</option>`;
        });

        currentLiga = select.value;
        switchLiga();
    }

    async function addLiga() {
        const nome = document.getElementById('nova-liga-nome').value.trim();
        if (!nome) return;

        const store = transaction(STORE_LIGAS, 'readwrite');
        try {
            await putData(store, { nome });
            document.getElementById('nova-liga-nome').value = '';
            await loadLigas();
            document.getElementById('liga-select').value = nome;
            switchLiga();
        } catch (e) {
            document.getElementById('log').textContent = `Erro ao adicionar liga: ${e.message}`;
            document.getElementById('log').classList.add('error');
        }
    }

    async function deleteLiga() {
        if (!currentLiga || !confirm(`Tem certeza que deseja DELETAR a liga "${currentLiga}" e todos os seus dados de times e hist√≥rico?`)) return;

        // 1. Delete LIGA entry
        await deleteData(transaction(STORE_LIGAS, 'readwrite'), currentLiga);

        // 2. Delete all TIMES associated with the league
        const timeStore = transaction(STORE_TIMES, 'readwrite');
        const times = await getTimesByLiga(currentLiga);
        for (const time of times) {
            await deleteData(timeStore, time.id);
        }
        
        // 3. Delete all CONFRONTOS associated with the league
        const confrontoStore = transaction(STORE_CONFRONTOS, 'readwrite');
        const confrontos = await getConfrontosByLiga(currentLiga);
        for (const confronto of confrontos) {
            await deleteData(confrontoStore, confronto.id);
        }

        currentLiga = '';
        await loadLigas();
        document.getElementById('log').textContent = `Liga "${currentLiga}" deletada.`;
    }

    function switchLiga() {
        currentLiga = document.getElementById('liga-select').value;
        if (currentLiga) {
            loadTimesAndRender();
        }
    }

    // --- TIME MANAGEMENT ---

    async function loadTimesAndRender() {
        const times = await getTimesByLiga(currentLiga);
        renderTimeList(times);
        renderHistoricoInputs(times); // RENDERIZA OS CARDS
        renderConfrontoSelects(times);
        loadConfrontos();
        calculateAnalysis();
    }

    function renderTimeList(times) {
        document.getElementById('time-list-display').textContent = times.map(t => t.nome).join(', ');
    }

    async function addTime() {
        const nome = document.getElementById('novo-time-nome').value.trim();
        if (!nome || !currentLiga) return;

        const timeStore = transaction(STORE_TIMES, 'readwrite');
        try {
            await putData(timeStore, { liga: currentLiga, nome, historico: {} }); 
            document.getElementById('novo-time-nome').value = '';
            loadTimesAndRender();
        } catch (e) {
            document.getElementById('log').textContent = `Erro ao adicionar time: ${e.message}`;
            document.getElementById('log').classList.add('error');
        }
    }

    // --- NOVO RENDER DO HIST√ìRICO (SE√á√ÉO 3) E INPUTS (SE√á√ÉO 7) ---

    // Fun√ß√£o de wrapper que substitui o antigo renderHistoricoInputs
    function renderHistoricoInputs(times) {
        // Renderiza os cards de times (Se√ß√£o 3)
        renderTimeCards(times);
        // Renderiza os selects para a Se√ß√£o 7 (Inserir Resultados)
        renderResultInputSelects(times);
        // Atualiza display da GTR Base
        document.getElementById('gtr-base-display').textContent = METHODS[currentMethod].gtr_base;
    }
    
    // Cria e insere os cards de times na Se√ß√£o 3
    function renderTimeCards(times) {
        const container = document.getElementById('historico-inputs'); 
        if (!container) return; 
        
        container.innerHTML = '';
        if (times.length === 0) return;

        const rodadaAlvo = parseInt(document.getElementById('rodada-alvo').value);

        times.forEach(time => {
            const card = createTeamCard(time, rodadaAlvo);
            container.appendChild(card);
        });
        
        document.getElementById('target-r-display').textContent = rodadaAlvo;
        document.getElementById('confronto-r-display').textContent = rodadaAlvo;
        document.getElementById('analysis-r-display').textContent = rodadaAlvo;
    }

    // Cria o card de um time espec√≠fico com seu hist√≥rico (agora expans√≠vel).
    function createTeamCard(time, rodadaAlvo) {
        const teamCard = document.createElement('div');
        teamCard.className = 'input-box team-card'; 
        teamCard.setAttribute('data-time-id', time.id);
        teamCard.innerHTML = `<h3>${time.nome}</h3>`;

        const historicoDiv = document.createElement('div');
        historicoDiv.className = 'historico-gols';

        const maxRodada = rodadaAlvo - 1;
        const rodadas = Object.keys(time.historico).map(Number).sort((a, b) => a - b).filter(r => r <= maxRodada);
        
        const gtrBase = METHODS[currentMethod].gtr_base;
        const rodadasVisiveis = gtrBase; 
        const rodadasParaExibir = rodadas.slice(-rodadasVisiveis);
        const rodadasOcultas = rodadas.slice(0, rodadas.length - rodadasVisiveis);

        let htmlHistorico = '';

        // 1. ADICIONAR AS RODADAS OCULTAS (Se houver)
        if (rodadasOcultas.length > 0) {
            htmlHistorico += `
                <div class="hidden-history" id="hidden-r-${time.id}" style="display: none;">
            `;
            rodadasOcultas.forEach(r => {
                const data = time.historico[r] || { gm: 0, gs: 0, gmht: 0, gsht: 0 };
                const resultStyle = data.gm > data.gs ? 'win' : data.gm < data.gs ? 'loss' : 'draw';
                htmlHistorico += `
                    <div class="rodada-item ${resultStyle}" data-rodada="${r}" onclick="editResult(${time.id}, ${r}, '${time.liga}')">
                        <span class="rodada-label">R${r}</span>
                        <span class="placar-total">${data.gm} - ${data.gs}</span>
                        <span class="placar-ht" title="Placar 1¬∫ Tempo">(HT: ${data.gmht || 0} - ${data.gsht || 0})</span>
                    </div>
                `;
            });
             htmlHistorico += `</div>`; 
        }

        // 2. ADICIONAR BOT√ÉO DE EXPANDIR (Se houver rodadas ocultas)
        if (rodadasOcultas.length > 0) {
             htmlHistorico += `
                <button class="expand-button" id="expand-btn-${time.id}" onclick="toggleHistory(${time.id})">
                    Mostrar ${rodadasOcultas.length} Rodadas Anteriores
                </button>
            `;
        }

        // 3. ADICIONAR AS RODADAS RELEVANTES (√öltimas N do GTR)
        htmlHistorico += `<div class="flex-group" style="gap: 5px; margin-top: 10px;">`
        rodadasParaExibir.forEach(r => {
            const data = time.historico[r] || { gm: 0, gs: 0, gmht: 0, gsht: 0 };
            const resultStyle = data.gm > data.gs ? 'win' : data.gm < data.gs ? 'loss' : 'draw';
            const analyzedClass = ' analyzed-r'; 

            htmlHistorico += `
                <div class="rodada-item ${resultStyle}${analyzedClass}" data-rodada="${r}" onclick="editResult(${time.id}, ${r}, '${time.liga}')" style="flex: 1; min-width: 80px;">
                    <span class="rodada-label">R${r}</span>
                    <span class="placar-total">${data.gm} - ${data.gs}</span>
                    <span class="placar-ht" title="Placar 1¬∫ Tempo">(HT: ${data.gmht} - ${data.gsht})</span>
                </div>
            `;
        });
        htmlHistorico += `</div>`
        
        historicoDiv.innerHTML = htmlHistorico;
        teamCard.appendChild(historicoDiv);
        return teamCard;
    }

    // Preenche a se√ß√£o 7 com os dados de um resultado clicado (usado pelo onclick do card)
    async function editResult(timeId, rodada, liga) {
        showInputSection(); 
        
        const timeStore = transaction(STORE_TIMES, 'readonly');
        const time = await getData(timeStore, timeId);
        
        if (!time) return;

        const todosTimes = await getTimesByLiga(liga);
        const data = time.historico[rodada] || {};

        document.getElementById('rodada-input').value = rodada;
        document.getElementById('gm-input').value = data.gm !== undefined ? data.gm : '';
        document.getElementById('gs-input').value = data.gs !== undefined ? data.gs : '';
        document.getElementById('gmht-input').value = data.gmht !== undefined ? data.gmht : '';
        document.getElementById('gsht-input').value = data.gsht !== undefined ? data.gsht : '';
        
        renderResultInputSelects(todosTimes, timeId, 0); 

        document.getElementById('log').textContent = `Pronto para editar R${rodada} de ${time.nome}. Se for inserir um novo jogo, preencha o Advers√°rio.`;
    }

    // Preenche os selects da se√ß√£o 7 (Inserir Resultados)
    function renderResultInputSelects(times, selectedTimeId1 = 0, selectedTimeId2 = 0) {
        const select1 = document.getElementById('time1-result-select');
        const select2 = document.getElementById('time2-result-select');
        select1.innerHTML = '<option value="">-- Time 1 --</option>';
        select2.innerHTML = '<option value="0">-- Advers√°rio (Opcional) --</option>';

        times.forEach(time => {
            const isSelected1 = time.id === selectedTimeId1 ? 'selected' : '';
            const isSelected2 = time.id === selectedTimeId2 ? 'selected' : '';
            
            select1.innerHTML += `<option value="${time.id}" ${isSelected1}>${time.nome}</option>`;
            select2.innerHTML += `<option value="${time.id}" ${isSelected2}>${time.nome}</option>`;
        });
    }

    // Salva o resultado da se√ß√£o 7
    async function saveResultFromInputs() {
        const timeId1 = parseInt(document.getElementById('time1-result-select').value);
        const timeId2 = parseInt(document.getElementById('time2-result-select').value) || 0;
        const rodada = parseInt(document.getElementById('rodada-input').value);

        const gm = parseInt(document.getElementById('gm-input').value) || 0;
        const gs = parseInt(document.getElementById('gs-input').value) || 0;
        const gmht = parseInt(document.getElementById('gmht-input').value) || 0;
        const gsht = parseInt(document.getElementById('gsht-input').value) || 0;

        if (!timeId1 || !rodada) {
            document.getElementById('log').textContent = 'Erro: Selecione um Time e insira a Rodada.';
            document.getElementById('log').classList.add('error');
            return;
        }

        const timeStore = transaction(STORE_TIMES, 'readwrite');
        const time1 = await getData(timeStore, timeId1);
        
        if (!time1.historico[rodada]) {
            time1.historico[rodada] = {};
        }

        // Salva os dados para o Time 1 (GM = gols marcados, GS = gols sofridos)
        time1.historico[rodada].gm = gm;
        time1.historico[rodada].gs = gs;
        time1.historico[rodada].gmht = gmht;
        time1.historico[rodada].gsht = gsht;

        await putData(timeStore, time1);

        // Se o time 2 foi selecionado (Advers√°rio) - Salva o inverso para ele
        if (timeId2 && timeId2 !== 0 && timeId2 !== timeId1) {
             const time2 = await getData(timeStore, timeId2);
             if (!time2.historico[rodada]) {
                 time2.historico[rodada] = {};
             }
             // Time 2: GM = gols sofridos do Time 1, GS = gols marcados do Time 1
             time2.historico[rodada].gm = gs;
             time2.historico[rodada].gs = gm;
             time2.historico[rodada].gmht = gsht;
             time2.historico[rodada].gsht = gmht;
             await putData(timeStore, time2);
             document.getElementById('log').textContent = `Resultado R${rodada} de ${time1.nome} vs ${time2.nome} salvo!`;
        } else {
             document.getElementById('log').textContent = `Resultado R${rodada} de ${time1.nome} salvo! (Apenas um time atualizado)`;
        }

        loadTimesAndRender(); 
    }

    // --- CONFRONTO MANAGEMENT ---

    function renderConfrontoSelects(times) {
        const select1 = document.getElementById('time1-select');
        const select2 = document.getElementById('time2-select');
        select1.innerHTML = '<option value="">-- Time 1 --</option>';
        select2.innerHTML = '<option value="">-- Time 2 --</option>';

        times.forEach(time => {
            select1.innerHTML += `<option value="${time.nome}">${time.nome}</option>`;
            select2.innerHTML += `<option value="${time.nome}">${time.nome}</option>`;
        });
    }

    async function addConfronto() {
        const time1 = document.getElementById('time1-select').value;
        const time2 = document.getElementById('time2-select').value;
        const rodada = parseInt(document.getElementById('rodada-alvo').value);

        if (!time1 || !time2 || time1 === time2 || !rodada) return;

        const confrontoStore = transaction(STORE_CONFRONTOS, 'readwrite');
        
        const allConfrontos = await getConfrontosByLiga(currentLiga);
        const isDuplicate = allConfrontos.some(c => 
            c.rodada === rodada && 
            ((c.time1 === time1 && c.time2 === time2) || (c.time1 === time2 && c.time2 === time1))
        );

        if (isDuplicate) {
             document.getElementById('log').textContent = 'Erro: Confronto j√° adicionado para esta rodada.';
             document.getElementById('log').classList.add('error');
             return;
        }

        try {
            await putData(confrontoStore, { liga: currentLiga, rodada, time1, time2 });
            document.getElementById('log').textContent = `Confronto ${time1} vs ${time2} (R${rodada}) adicionado.`;
            calculateAnalysis(); 
        } catch (e) {
            document.getElementById('log').textContent = `Erro ao adicionar confronto: ${e.message}`;
            document.getElementById('log').classList.add('error');
        }
    }

    async function loadConfrontos() {
        // Nada a fazer aqui, pois o c√°lculo de an√°lise faz isso
    }
    
    // --- UTILITY DB FUNCTIONS ---

    function getAllData(store) {
        return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function getData(store, key) {
        return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function putData(store, data) {
        return new Promise((resolve, reject) => {
            const request = store.put(data);
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    function deleteData(store, key) {
        return new Promise((resolve, reject) => {
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    async function getTimesByLiga(ligaNome) {
        const timeStore = transaction(STORE_TIMES, 'readonly');
        const index = timeStore.index('liga');
        const request = index.getAll(ligaNome);
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }

    async function getConfrontosByLiga(ligaNome) {
        const confrontoStore = transaction(STORE_CONFRONTOS, 'readonly');
        const allConfrontos = await getAllData(confrontoStore);
        return allConfrontos.filter(c => c.liga === ligaNome);
    }

    async function getConfrontosByLigaAndRodada(ligaNome, rodada) {
        const confrontoStore = transaction(STORE_CONFRONTOS, 'readonly');
        const allConfrontos = await getAllData(confrontoStore);
        return allConfrontos.filter(c => c.liga === ligaNome && c.rodada === rodada);
    }
    
    // --- EXPORT/IMPORT DATA ---
// ... (mantenha sua fun√ß√£o exportData original aqui) ...

// Fun√ß√£o importData ATUALIZADA para aceitar JSON OU HTML
async function importData(event) {
    const file = event.target.files[0];
    if (!file) return;

    document.getElementById('log').textContent = `Iniciando importa√ß√£o do arquivo: ${file.name}`;
    document.getElementById('log').classList.remove('error');

    const reader = new FileReader();
    
    reader.onload = async (e) => {
        const content = e.target.result;

        try {
            if (file.name.endsWith('.json')) {
                // --- L√ìGICA DE IMPORTA√á√ÉO JSON (BACKUP) ---
                const data = JSON.parse(content);

                if (!data.metadata || data.metadata !== "TMG 2.0 Export") {
                    throw new Error('Arquivo JSON inv√°lido ou n√£o √© um arquivo TMG 2.0 Export.');
                }

                if (!confirm("Tem certeza que deseja importar dados? Isso IR√Å SOBRESCREVER TODOS os dados existentes (Ligas, Times, Confrontos).")) {
                    document.getElementById('import-file').value = ''; 
                    return;
                }
                
                // Sobrescrever dados no IndexedDB
                await overwriteStore(STORE_LIGAS, data.ligas);
                await overwriteStore(STORE_TIMES, data.times);
                await overwriteStore(STORE_CONFRONTOS, data.confrontos);
                
                document.getElementById('log').textContent = `Importa√ß√£o JSON COMPLETA (${data.ligas.length} ligas) conclu√≠da!`;

            } else if (file.name.endsWith('.html')) {
                // --- L√ìGICA DE IMPORTA√á√ÉO HTML (RESULTADOS) ---
                if (!currentLiga) {
                     throw new Error("Erro: Selecione uma Liga Ativa antes de importar resultados HTML.");
                }

                const gameResults = parseHtmlTable(content);
                
                if (gameResults && gameResults.length > 0) {
                    await processHtmlImport(gameResults);
                    document.getElementById('log').textContent = `Importa√ß√£o HTML de ${gameResults.length} resultados para a liga "${currentLiga}" conclu√≠da!`;
                } else {
                    throw new Error('Nenhum resultado v√°lido encontrado no arquivo HTML.');
                }
            } else {
                throw new Error('Formato de arquivo n√£o suportado. Use .json (backup) ou .html (resultados).');
            }

            // A√ß√µes finais
            document.getElementById('import-file').value = '';
            await loadLigas(); 

        } catch (error) {
            document.getElementById('log').textContent = `Erro durante o processamento do arquivo: ${error.message}`;
            document.getElementById('log').classList.add('error');
        }
    };

    reader.readAsText(file);
}
    
    // UTILITY para limpar e preencher um Store (banco de dados)
    async function overwriteStore(storeName, dataArray) {
        const store = transaction(storeName, 'readwrite');
        await clearStore(store);
        for (const item of dataArray) {
            await putData(store, item);
        }
    }

    // UTILITY para limpar um Store
    function clearStore(store) {
        return new Promise((resolve, reject) => {
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // --- C√ÅLCULO E AN√ÅLISE ---

    function setMethod() {
        currentMethod = document.getElementById('metodo-select').value;
        document.getElementById('log').textContent = `M√©todo de an√°lise alterado para ${METHODS[currentMethod].name}.`;
        loadTimesAndRender(); // Recarrega para atualizar o GTR base
    }

    function getHistoricoGols(time, rodada) {
        return time.historico[rodada] || { gm: null, gs: null, gmht: null, gsht: null };
    }

    function calculateTMG_GMGS(gmgs1, gmgs2) {
        if (gmgs1 === null || gmgs2 === null) return null;
        return gmgs1 + gmgs2;
    }

    async function calculateGTRs(times, targetR, gtrBase, type) {
        const gtrScores = {};
        const maxR = targetR - 1; 
        const startR = maxR - gtrBase + 1;

        times.forEach(time => {
            let totalGols = 0;
            let incomplete = false;

            for (let r = startR; r <= maxR; r++) {
                const data = getHistoricoGols(time, r);
                let gols;
                
                if (type === 'TOTAL') {
                    gols = calculateTMG_GMGS(data.gm, data.gs);
                } else if (type === 'HT') {
                    gols = calculateTMG_GMGS(data.gmht, data.gsht);
                }
                
                if (gols !== null) {
                    totalGols += gols;
                } else {
                    incomplete = true;
                    break; 
                }
            }

            gtrScores[time.nome] = incomplete ? null : totalGols;
        });
        return gtrScores;
    }

    async function calculateApostaOuro(times) {
        const apostaOuroList = [];
        const maxR = parseInt(document.getElementById('rodada-alvo').value) - 1;
        const startR = maxR - 9; 
        if (startR < 1) return apostaOuroList; 

        times.forEach(time => {
            let over25Count = 0;
            let totalCount = 0;
            let incomplete = false;

            for (let r = startR; r <= maxR; r++) {
                const data = getHistoricoGols(time, r);
                if (data.gm !== null && data.gs !== null) {
                    totalCount++;
                    if (data.gm + data.gs >= 3) { // Over 2.5
                        over25Count++;
                    }
                } else {
                    incomplete = true;
                    break;
                }
            }
            
            // Regra: 90% (9 de 10) dos jogos com Over 2.5 nas √∫ltimas 10 rodadas.
            if (totalCount === 10 && !incomplete && (over25Count / 10) >= 0.9) {
                apostaOuroList.push(time.nome);
            }
        });

        return apostaOuroList;
    }


    async function calculateAnalysis() {
        const targetR = parseInt(document.getElementById('rodada-alvo').value);
        if (!currentLiga || !targetR) return;

        const method = METHODS[currentMethod];
        const times = await getTimesByLiga(currentLiga);
        const gtrScores = await calculateGTRs(times, targetR, method.gtr_base, method.type);
        const confrontos = await getConfrontosByLigaAndRodada(currentLiga, targetR);
        apostaOuroTimes = await calculateApostaOuro(times); 

        document.getElementById('gtr-calc-info').textContent = `${method.type === 'TOTAL' ? 'Gols Totais (GM+GS)' : 'Gols 1¬∫ Tempo (GM HT + GS HT)'} das √∫ltimas ${method.gtr_base} rodadas.`;
        document.getElementById('gtr-base-display').textContent = method.gtr_base;
        
        const elegiveis = [];
        const tmgTableBody = document.getElementById('tmg-table').querySelector('tbody') || document.createElement('tbody');
        tmgTableBody.innerHTML = '';
        document.getElementById('tmg-table').appendChild(tmgTableBody);

        // 1. Render GTR Table
        renderGTRTable(times, gtrScores, method);

        // 2. TMG Analysis
        confrontos.forEach((c, index) => {
            const tmg = calculateTMG_GMGS(gtrScores[c.time1], gtrScores[c.time2]);
            const isElegivel = tmg !== null && tmg >= method.tmg_min;
            const isOuro = (method.type === 'TOTAL') && (apostaOuroTimes.includes(c.time1) || apostaOuroTimes.includes(c.time2));

            let elegivelClass = isElegivel ? 'elegivel' : '';
            if (isOuro) elegivelClass = 'aposta-ouro';

            if (isElegivel && !isOuro) { 
                elegiveis.push({ ...c, tmg, id: c.id });
            }

            const tmgDisplay = tmg !== null ? tmg : 'DADOS PENDENTES';
            let statusDisplay = isElegivel ? 'SIM' : 'N√ÉO';
            if (isOuro) statusDisplay = 'APOSTA OURO (FORA)';

            const rowHTML = `
                <tr class="${elegivelClass}">
                    <td>J${index + 1}</td>
                    <td>${c.time1} vs ${c.time2}</td>
                    <td>${gtrScores[c.time1] !== null ? gtrScores[c.time1] : '-'}</td>
                    <td>${gtrScores[c.time2] !== null ? gtrScores[c.time2] : '-'}</td>
                    <td>${tmgDisplay}</td>
                    <td>${statusDisplay}</td>
                    <td><button onclick="removeConfrontoById(${c.id})" class="btn-danger" style="margin-right: 0;">Remover</button></td>
                </tr>
            `;
            tmgTableBody.innerHTML += rowHTML;
        });

        // 3. Chave Recommendation
        renderChaveRecomendacao(elegiveis, method);
        renderHistoricoInputs(times); // Recarrega os cards ap√≥s recalcular a GTR base
    }
    
    // --- REMOVAL UTILITIES ---

    async function removeConfrontoById(id) {
        const confrontoStore = transaction(STORE_CONFRONTOS, 'readwrite');
        await deleteData(confrontoStore, id);
        calculateAnalysis();
    }

    // --- RENDER REPORT FUNCTIONS ---

    function renderGTRTable(times, gtrScores, method) {
        const table = document.getElementById('gtr-table');
        const maxR = parseInt(document.getElementById('rodada-alvo').value) - 1;
        const startR = maxR - method.gtr_base + 1;

        let html = `<thead><tr><th>Time</th>`;
        
        for (let r = startR; r <= maxR; r++) {
            html += `<th>${method.type === 'TOTAL' ? 'GM+GS' : 'HTGTR'} (R${r})</th>`;
        }
        
        html += `<th>GTR (Base ${method.gtr_base}R)</th>`;
        if (method.type === 'TOTAL') {
             html += `<th>Aposta Ouro?</th>`;
        }
        html += `</tr></thead><tbody>`;

        times.forEach(time => {
            let rowHTML = `<tr><td>${time.nome}</td>`;
            let gtrDisplay = gtrScores[time.nome] !== null ? gtrScores[time.nome] : 'PENDENTE';
            let isOuro = apostaOuroTimes.includes(time.nome) ? 'SIM' : 'N√ÉO';

            for (let r = startR; r <= maxR; r++) {
                const data = getHistoricoGols(time, r);
                let gols = null;
                if (method.type === 'TOTAL') {
                    gols = calculateTMG_GMGS(data.gm, data.gs);
                } else if (method.type === 'HT') {
                    gols = calculateTMG_GMGS(data.gmht, data.gsht);
                }
                
                rowHTML += `<td>${gols !== null ? gols : '-'}</td>`;
            }
            
            rowHTML += `<td>${gtrDisplay}</td>`;
            if (method.type === 'TOTAL') {
                rowHTML += `<td class="${isOuro === 'SIM' ? 'aposta-ouro' : ''}">${isOuro}</td>`;
            }
            rowHTML += `</tr>`;
            html += rowHTML;
        });
        
        html += `</tbody>`;
        table.innerHTML = html;
    }

    // --- FUN√á√ïES DE COMBINA√á√ÉO E CHAVE ---

    /**
     * Gera todas as combina√ß√µes de k elementos de um array.
     */
    function generateCombinations(array, k) {
        let result = [];
        if (k > array.length || k <= 0) {
            return result;
        }
        if (k === 1) {
            return array.map(element => [element]);
        }
        
        array.forEach((current, index) => {
            const remaining = array.slice(index + 1);
            const subCombinations = generateCombinations(remaining, k - 1);
            subCombinations.forEach(subCombination => {
                result.push([current].concat(subCombination));
            });
        });
        return result;
    }

    /**
     * Gera o HTML para a exibi√ß√£o de uma Chave.
     */
    function generateChaveHtml(jogos, entradas, resumo) {
        let html = `<div style="border: 1px solid #ccc; padding: 15px; margin-top: 10px; border-radius: 5px; background: #f9f9f9;">`;
        
        html += `<h4>Jogos Envolvidos (TMG)</h4><ul>`;
        jogos.forEach(j => {
            html += `<li>J${j.id}: **${j.time1} vs ${j.time2}** (TMG: ${j.tmg})</li>`;
        });
        html += `</ul>`;
        
        html += `<p style="font-weight: bold; margin-top: 10px;">${resumo}</p>`;
        
        html += `<h4>Entradas Sugeridas (${entradas.length} combina√ß√µes)</h4>`;
        html += `<div style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: #fff;">`;
        entradas.forEach((entrada, idx) => {
            const nomes = entrada.map(j => `J${j.id} (${j.time1}/${j.time2})`).join(' + ');
            html += `<p style="margin: 5px 0; font-size: 0.9em;">${idx + 1}. ${nomes}</p>`;
        });
        html += `</div></div>`;
        
        return html;
    }

    // --- RENDERIZA√á√ÉO FINAL DA RECOMENDA√á√ÉO ---
    
    function renderChaveRecomendacao(elegiveis, method) {
        const recomendacaoDiv = document.getElementById('chave-recomendacao');
        const N = elegiveis.length;
        
        if (N === 0) {
            recomendacaoDiv.innerHTML = `<p>Nenhum jogo eleg√≠vel para a Chave Condicionada (TMG ‚â• ${method.tmg_min}).</p>`;
            return;
        }

        elegiveis.sort((a, b) => b.tmg - a.tmg);

        let html = `<h3>${method.name} - Recomenda√ß√£o Final</h3>
                        <p><strong>Mercado Alvo:</strong> ${method.market}</p>
                        <p><strong>Jogos Eleg√≠veis Totais (N):</strong> ${N}</p>`;
        
        let chavesGeradas = false;

        // L√ìGICA CHAVE DO M√âTODO 1 (TMG-Chave Otimizado)
        if (method.chave_rule === 'CHAVE_2_4') {
            const K = Math.min(N, 4); 
            const topK = elegiveis.slice(0, K);
            const entradas = generateCombinations(topK, 2);
            
            html += `<h4 style="color: #28a745;">ESTRAT√âGIA CHAVE 2/${K} (Foco nos ${K} jogos de maior TMG)</h4>`;
            html += generateChaveHtml(topK, entradas, `Acerto de 2 ou mais jogos. Total de Entradas: ${entradas.length}`);
            chavesGeradas = true;

        // L√ìGICA CHAVE DO M√âTODO 2 (TMG-Chave O2.5)
        } else if (method.chave_rule === 'CHAVE_MULTIPLA') {
            const top20 = elegiveis.filter(j => j.tmg >= 20);
            const mid15 = elegiveis.filter(j => j.tmg >= 15 && j.tmg <= 19);

            if (top20.length >= 5) {
                // CHAVE 3/5
                const top5 = top20.slice(0, 5);
                const entradas3_5 = generateCombinations(top5, 3);
                html += `<h4 style="color: #dc3545;">üöÄ CHAVE PRINCIPAL 3/5 (TMG ‚â• 20)</h4>`;
                html += generateChaveHtml(top5, entradas3_5, `Acerto de 3/5 jogos. Total de Entradas: ${entradas3_5.length}`);
                chavesGeradas = true;
            }

            if (mid15.length >= 3) {
                // CHAVE 2/3
                const top3 = mid15.slice(0, 3);
                const entradas2_3 = generateCombinations(top3, 2);
                html += `<h4 style="color: #ffc107;">‚≠ê CHAVE SECUND√ÅRIA 2/3 (TMG 15-19)</h4>`;
                html += generateChaveHtml(top3, entradas2_3, `Acerto de 2/3 jogos. Total de Entradas: ${entradas2_3.length}`);
                chavesGeradas = true;
            }
            
            if (!chavesGeradas) {
                 html += `<p>N√£o h√° jogos o suficiente (m√≠nimo 5 TMG ‚â• 20 ou 3 TMG 15-19) para gerar as chaves m√∫ltiplas.</p>`;
            }

        // L√ìGICA CHAVE DO M√âTODO 3 (TMG-Chave HT Otimizado)
        } else if (method.chave_rule === 'CHAVE_2_N') {
            const N_chave = Math.min(N, 6); 
            const topN = elegiveis.slice(0, N_chave);
            
            if (N_chave >= 2) {
                const entradas = generateCombinations(topN, 2);
                html += `<h4 style="color: #007bff;">ESTRAT√âGIA CHAVE 2/${N_chave} (Foco nos ${N_chave} jogos de maior TMG HT)</h4>`;
                html += generateChaveHtml(topN, entradas, `Acerto de 2 ou mais jogos. Total de Entradas: ${entradas.length}`);
                chavesGeradas = true;
            } else {
                 html += `<p>M√≠nimo de 2 jogos TMG HT eleg√≠veis para gerar a chave.</p>`;
            }
        }
        
        if (N > 0 && !chavesGeradas) {
            html += `<p>Jogos eleg√≠veis, mas n√£o se encaixam nas regras de volume de jogos para gerar as chaves autom√°ticas.</p>`;
        }

        recomendacaoDiv.innerHTML = html;
    }
    
    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', openDB);

</script>

</body>
</html>

